:project: Les colons de Catane

= Spécification des exigences

== Introduction 

Ce chapitre décrit les exigences du projet «{project}». Il suit la norme IEEE 830-1998.

L'objectif de ce document est de décrire les spécifications des exigences du projet "{project}" pour les étudiants en génie logiciel.

=== Définitions, acronymes et abréviations

Aucune jusqu'à présent.

=== Public visé et suggestions de lecture

Le public visé par cette spécification sont les développeurs ainsi que les personnes chargées de l'évaluation technique de l'application.

La section <<description>> s'adresse à tous les lecteurs de ce document. Elle permet de bien comprendre le but de cette application. 

La partie <<contrainte>> s'adresse principalement aux développeurs, et défini toutes les bonnes pratiques, les contraintes et les différentes technologies à utiliser pour le développement de cette application. 

La section <<features>> s'adresse une nouvelle fois aux développeurs et aux personnes chargées de l'évaluation technique. Cette section décrit concrètement toutes les fonctionnalitées que doit posséder l'application. 

Enfin, la partie <<nonfunctional>> s'adresse exclusivement aux développeurs.

=== Portée du projet

Le système logiciel à produire est une version simplifiée du jeu de plateau {project}, qui sera désigné par le terme "{project}" dans le présent document.

Le système {project} permettra à des joueurs de différents endroits de s'affronter dans des parties courtes et intensives.

=== Références

. IEEE Standard 830-1993: IEEE Recommended Practice for Software Requirements Specifications

=== Vue d’ensemble 

Le reste de ce document contient une description globale du système logiciel {project} (section <<description>>, les exigences fonctionnelles spécifiques (section <<features>>) et les exigences non-fonctionnelles du système (voir <<nonfunctional>>).

== Organisation du chapitre

[#description]
== Description générale

=== Perspectives du produit

{project} est un jeu de cartes où plusieurs joueurs s'affrontent.
Le logiciel {project} doit permettre aux joueurs qui sont connectés à Internet d'utiliser leurs appareils connectés pour jouer.
Ainsi, "{project}" est une version électronique en ligne du jeu de cartes.

Bien que le système soit distribué et organisé en différents composants, les joueurs doivent le percevoir comme un seul logiciel.
La figure <<deployment>> présente l'architecture globale du logiciel.
Les joueurs interagissent avec un client Web, qui utilise le protocole HTTP pour communiquer avec (au maximum) un serveur de jeu.
Les serveurs utilisent le protocole TCP/IP pour communiquer avec un serveur de gestion de base de données, qui stocke toutes les données du logiciel.

[#deployment]
.Diagramme de déploiement 
[plantuml]
----
include::partial$DeploymentDiagramsCatan.puml[]
----

=== Fonctionnalités du produit

Le logiciel {project} doit assurer deux fonctions principales :

. Création de jeu : permettre à deux joueurs de se découvrir et de commencer une partie.
. Le jeu{nbsp}: permettre aux joueurs de jouer effectivement à {project} jusqu'à la victoire de l'un d'entre eux.

[NOTE]
====
Une image des principaux groupes d'exigences connexes et de leurs relations, comme une carte conceptuelle, est souvent utile.
====


=== Caractéristiques et classes d'utilisateurs

[NOTE]
====
Identifiez les différentes classes d'utilisateurs qui, selon vous, utiliseront ce produit. 
Les classes d'utilisateurs peuvent être différenciées en fonction de la fréquence d'utilisation, du sous-ensemble de fonctions du produit utilisé, de l'expertise technique, des niveaux de sécurité ou de privilège, du niveau d'éducation ou de l'expérience. 
Décrivez les caractéristiques pertinentes de chaque classe d'utilisateurs.  Certaines exigences peuvent ne concerner que certaines classes d'utilisateurs. 
Distinguez les classes d'utilisateurs les plus importantes pour ce produit de celles qui sont moins importantes à satisfaire.
====

Le logiciel {project} n'a qu'une seule classe d'utilisateurs : les joueurs.
Les joueurs peuvent avoir différents niveaux : débutants, intermédiaires ou experts.
Cependant, indépendamment de leur niveau, les joueurs doivent utiliser la même interface utilisateur pour jouer les uns contre les autres.
Il doit être possible d'inviter différents joueurs à jouer ensemble.

[#nonfunctional]

[#nonfunctional]


=== Environnement opérationnel

NOTE: Décrivez l'environnement dans lequel le logiciel fonctionnera, y compris la plate-forme matérielle, le système d'exploitation et ses versions, ainsi que tout autre composant logiciel ou application avec lequel il doit coexister pacifiquement.

Le logiciel {project} doit fonctionner sur tout système d'exploitation populaire et récent{nbsp}: Linux, Windows, ou MacOS.
Le client Web devrait fonctionner sur tout navigateur Web récent{nbsp}: Firefox, Chrome, Safari, ou Edge.

[NOTE]
====
TODO: Complétez la description ci-dessus
====

[#contrainte]
== Contraintes de conception et de mise en œuvre

=== Langages de programmation

. Le serveur de jeu doit être développé en Java (version ≥ 11), en utilisant le https://spring.io [Spring Framework].
. Le client doit être développé en TypeScript (version ≥ 4.0), en utilisant le https://angular.io [Angular Framework].


=== Langage de conception

. Les documents sur le développement du logiciel doivent être écrits dans le format Asciidoc.
. Les diagrammes UML d'analyse, conception et mise en œuvre devront être réalisés en PlantUML.

=== Conception
=== Mise en œuvre

. Les tests dynamiques doivent utiliser JUnit (version >= 5.0) et Jasmine (version >= 3.5.0).
. Le code doit journaliser ses principales opérations en utilisant https://www.slf4j.org [SLF4J].

=== Outils de construction

. Tous les artefacts logiciels doivent utiliser un outil de construction : Maven ou Groovy pour Java, npm pour TypeScript.

=== Outils de développement
=== Bibliothèques et composants logiciels


== Vérification

. Les doubles tests doivent être utilisés pour tester chaque composant indépendamment.
. Chaque test unitaire doit décrire son intention.

== Documentation utilisateur

Aucune documentation utilisateur n'est requise pour la première version du logiciel.

=== Hypothèses et dépendances

Aucun jusqu'à présent.

=== Exigences reportées


Les versions futures du système comprendront l’utilisation d’un mécanisme de persistance de données ainsi que différentes interfaces utilisateur: web, IHM classique, etc. Elles permettront aussi l’accès distant à travers une interface REST.

Les versions futures pourraient permettre de jouer une partie avec plus de deux joueurs (3-4).

== Exigences en matière d'interface externe

=== Interfaces utilisateur

L'interface web du logiciel devra comporter les éléments suivants:

- un champ de saisie pour le nom du joueur
- un bouton pour lancer une partie
- un bouton pour quitter la partie
- plusieurs boutons représentant les actions possibles pour le joueur
- une représentation du plateau de jeu  
- les ressources d'un joueur (nombre de pièces, nombre de points de victoire ...)
- une représentation des cartes en main du joueur adverse


// [NOTE]
// ====
// Décrivez les caractéristiques logiques de chaque interface entre le produit logiciel et les utilisateurs. 

// Il peut s'agir d'exemples d'images d'écran, de normes d'interface graphique ou de guides de style de famille de produits à respecter, de contraintes de disposition des écrans, de boutons et de fonctions standard (p. ex., aide) qui apparaîtront sur chaque écran, de raccourcis clavier, de normes d'affichage des messages d'erreur, etc. 

// Définissez les composants logiciels pour lesquels une interface utilisateur est nécessaire. 
// Les détails de la conception de l'interface utilisateur doivent être documentés dans une spécification d'interface utilisateur distincte.
// ====

=== Interfaces matérielles

Le logiciel n'interagit pas directement avec un quelconque dispositif matériel.

=== Interfaces logicielles

La partie client du logiciel doit fonctionner sur des navigateurs web, tandis que la partie serveur doit interagir avec une base de données par le biais de l'API Java Persistence (JPA).



=== Interfaces de communication

Les communications entre le client et le serveur de jeu doivent utiliser des Websockets.

[#features]
== Exigences fonctionnelles

[NOTE]
====
Décrire les exigences fonctionnelles du système qui peuvent être exprimées et langage naturel. Pour plusieurs applications, c’est la partie principale de la SEL et son organisation doit, par conséquent, être bien réfléchie. Elle est habituellement hiérarchisée par caractéristiques, mais elle peut l’être, par utilisateur ou par sous-système. Les exigences fonctionnelles peuvent inclure les caractéristiques, les capacités et la sécurité.

Lorsque des outils de développement, tels des référentiels d’exigences ou des outils de modélisation sont utilisés, on peut référer à ces données en indiquant l’endroit et le nom de cet outil]
====

[TIP]
====
Ici, il ne s'agit plus de décrire le domaine métier, mais de spécifier ce que le système *doit* faire.

N'oubliez pas qu'il s'agit d'une spécification de que le système *doit* faire et non pas de *comment* il le fait.
====

=== Fonctionnalité Rejoindre une partie

[NOTE]
====
Ajoutez la description de la fonctionnalité "A".
====

TIP: Ne dites pas vraiment "Fonctionnalité A". Indiquez le nom de la fonctionnalité en quelques mots seulement.

==== Description et priorité

La fonctionnalité Rejoindre une partie permet à un joueur de rejoindre une partie en cours, en fournissant son nom.
Cette fonctionnalité a une priorité moyenne.

[NOTE]
====
Fournissez une brève description de la fonctionnalité et indiquez si elle a une priorité élevée, moyenne ou faible. 
Vous pouvez également inclure des évaluations spécifiques des éléments de priorité, comme les avantages, les pénalités, les coûts et les risques (chacun étant évalué sur une échelle relative allant de 1 à 9).
====

==== Séquences de Stimulus/Réponse

La fonctionnalité Rejoindre une partie est déclenchée par l'action de l'utilisateur de cliquer sur le bouton "Rejoindre une partie" de l'interface web.

NOTE: Liste des séquences d'actions de l'utilisateur et des réponses du système qui stimulent le comportement défini pour cette fonctionnalité. Celles-ci correspondront aux éléments de dialogue associés aux cas d'utilisation.

==== Exigences fonctionnelles
* REQ-1: Le système doit permettre à un joueur de fournir son nom.
* REQ-2: Le système doit permettre à un joueur de rejoindre une partie en cours.
* REQ-3: Le sustème doit vérifier que le nom du joueur est valide.


[NOTE]
====
Détaillez les exigences fonctionnelles détaillées associées à cette fonctionnalité. Il s'agit des capacités logicielles qui doivent être présentes pour permettre à l'utilisateur d'effectuer les services fournis par la fonction ou d'exécuter le cas d'utilisation. 

Indiquez comment le produit doit réagir aux conditions d'erreur prévues ou aux entrées non valides. Les exigences doivent être concises, complètes, non ambiguës, vérifiables et nécessaires. 

Utilisez la mention "A faire" pour indiquer que les informations nécessaires ne sont pas encore disponibles.

Chaque exigence doit être identifiée de manière unique par un numéro de séquence ou une étiquette significative.

* REQ-1:	
* REQ-2:
====

==== Description sous la forme d'un cas d'utilisation

.Cas d'utilisation A
include::partial$uc-a.adoc[]

=== Fonctionnalité Jouer un tour

La fonctionnalité Jouer un tour permet à un joueur de jouer un tour en choisissant quelles actions il veut effectuer.


==== Description et priorité

La fonctionnalité Jouer un tour permet à un joueur de jouer un tour en choisissant quelles actions il veut effectuer, en fonction de ses cartes en main et de la situation de la partie.
Cette fonctionnalité a une priorité moyenne.

==== Séquences de Stimulus/Réponse

La fonctionnalité Jouer un tour est déclenchée par le serveur qui indique au joueur qu'il est son tour de jouer.


==== Exigences fonctionnelles

* REQ-1: Le système doit permettre de communiquer au joueur qu'il est son tour de jouer.
* REQ-2: Le système doit permettre au joueur de choisir une action à effectuer.



==== Description sous la forme d'un cas d'utilisation
.Cas d'utilisation Jouer un tour
include::partial$uc-b.adoc[]

=== Fonctionnalité C

NOTE: Ajoutez la description de la fonctionnalité "C" en vous basant sur la structure de la fonctionnalité "A"

==== Description sous la forme d'un cas d'utilisation

.Cas d'utilisation C
include::partial$uc-c.adoc[]


[#nonfunctional]
== Autres exigences non-fonctionnelles

=== Exigences de performance 

. Le jeu doit être _jouable_, ce qui signifie que les utilisateurs doivent avoir un retour rapide de leurs actions et que les retards dus aux problèmes de communication/connexion doivent être correctement tenus.
. Le client Web doit pouvoir s'exécuter sur un ordinateur personnel doté de 4 Go de RAM.


=== Exigences de sécurité

NOTE: Précisez toute exigence concernant les questions de sécurité ou de confidentialité entourant l'utilisation du produit ou la protection des données utilisées ou créées par le produit. Définissez toute exigence en matière d'authentification de l'identité de l'utilisateur. Faites référence à toute politique ou réglementation externe contenant des questions de sécurité qui affectent le produit. Définissez toutes les certifications de sécurité ou de confidentialité qui doivent être satisfaites.

=== Attributs de qualité logicielle

[NOTE]
====
Précisez toute autre caractéristique de qualité du produit qui sera importante pour les clients ou les développeurs. En voici quelques-unes : adaptabilité, disponibilité, exactitude, flexibilité, interopérabilité, maintenabilité, portabilité, fiabilité, réutilisabilité, robustesse, testabilité et convivialité. 

Rédigez-les de manière à ce qu'elles soient spécifiques, quantitatives et vérifiables, si possible. 

Au minimum, clarifiez les préférences relatives pour divers attributs, comme la facilité d'utilisation par rapport à la facilité d'apprentissage. 
====

==== Extensibilité

NOTE: TODO

==== Maintenabilité

. Le logiciel doit être lisible et facile à maintenir.
. La source Java doit respecter les directives de Google : https://google-styleguide.googlecode.com/svn/trunk/javaguide.html.

=== Règles métier

NOTE: Énumérez tous les principes de fonctionnement du produit, tels que les personnes ou les rôles qui peuvent remplir telle ou telle fonction dans des circonstances spécifiques. Il ne s'agit pas d'exigences fonctionnelles en soi, mais elles peuvent impliquer certaines exigences fonctionnelles pour faire respecter les règles.


== Autres exigences

NOTE: Définissez toute autre exigence non couverte ailleurs dans le SRS. Il peut s'agir d'exigences relatives à la base de données, à l'internationalisation, à la législation, aux objectifs de réutilisation du projet, etc. Ajoutez toute nouvelle section pertinente pour le projet.

=== Annexe A : Glossaire

TIP: https://docs.asciidoctor.org/asciidoc/latest/sections/glossary/


NOTE: Définissez tous les termes nécessaires pour interpréter correctement le SRS, y compris les acronymes et les abréviations. Vous pouvez créer un glossaire distinct couvrant plusieurs projets ou l'ensemble de l'organisation, et vous contenter d'inclure les termes spécifiques à un seul projet dans chaque SRS.

=== Annexe B : Modèles d'analyse

Voir le chapitre <<domain>> (analyse du domaine) pour plus de détails.

NOTE: En option, inclure tout modèle d'analyse pertinent, tel que des diagrammes de flux de données, des diagrammes de classe, des diagrammes d'état-transition ou des diagrammes entité-relation.

=== Annexe C : Liste à déterminer

NOTE: Recueillir une liste numérotée des références TBD (To Be Done) qui restent dans le SRS afin de pouvoir les suivre jusqu'à leur fermeture.
