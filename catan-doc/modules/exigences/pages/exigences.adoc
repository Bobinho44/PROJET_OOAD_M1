:project: Les colons de Catane

= Spécification des exigences

== Introduction 

Ce chapitre décrit les exigences du projet «{project}». Il suit la norme IEEE 830-1998.

=== Avant-propos

L'objectif de ce document est de décrire les spécifications des exigences du projet "{project}" pour les étudiants en génie logiciel.

Le public visé par cette spécification comprend les développeurs potentiels de l'application, ainsi que les personnes chargées de l'évaluation technique.


=== Définitions, acronymes et abréviations

Aucune jusqu'à présent.

=== Public visé et suggestions de lecture

[NOTE]
====
Décrire les différents types de lecteurs auxquels le document est destiné, tels que les développeurs, les chefs de projet, le personnel du marketing, les utilisateurs, les testeurs et les rédacteurs de la documentation. 

Décrivez le contenu et l'organisation du reste de ce SRS. Suggérer un ordre de lecture du document, en commençant par les sections d'aperçu et en poursuivant par les sections les plus pertinentes pour chaque type de lecteur.
====

=== Portée du projet

Le système logiciel à produire est une version simplifiée du jeu de plateau {project}, qui sera désigné par le terme "{project}" dans le présent document.

Le système {project} permettra à des joueurs de différents endroits de s'affronter dans des parties courtes et intensives.

=== Références

. IEEE Standard 830-1993: IEEE Recommended Practice for Software Requirements Specifications

=== Vue d’ensemble 

Le reste de ce document contient une description globale du système logiciel {project} (section <<description>>, les exigences fonctionnelles spécifiques (section <<features>>) et les exigences non-fonctionnelles du système (voir <<nonfunctional>>).

== Organisation du chapitre

[#description]
== Description générale

=== Perspectives du produit

{project} est un jeu de cartes où plusieurs joueurs s'affrontent.
Le logiciel {project} doit permettre aux joueurs qui sont connectés à Internet d'utiliser leurs appareils connectés pour jouer.
Ainsi, "{project}" est une version électronique en ligne du jeu de cartes.

Bien que le système soit distribué et organisé en différents composants, les joueurs doivent le percevoir comme un seul logiciel.
La figure <<deployment>> présente l'architecture globale du logiciel.
Les joueurs interagissent avec un client Web, qui utilise le protocole HTTP pour communiquer avec (au maximum) un serveur de jeu.
Les serveurs utilisent le protocole TCP/IP pour communiquer avec un serveur de gestion de base de données, qui stocke toutes les données du logiciel.

[NOTE]
====
Améliorez le diagramme de déploiement pour qu'il représente le système que vous allez développer.

Pour plus de détails sur les diagrammes de déploiement{nbsp}:

* https://www.uml-diagrams.org/deployment-diagrams-overview.html
====

[#deployment]
.UML Diagramme de déploiement 
[plantuml]
----
include::example$deployment-diagram.puml[]
----

[NOTE]
====
Décrivez le contexte et l'origine du produit spécifié dans ce SRS.  
Par exemple, indiquez si ce produit est un membre suivant d'une famille de produits, un remplacement de certains systèmes existants ou un nouveau produit autonome. 

Si le SRS définit un composant d'un système plus vaste, faites le lien entre les exigences du système plus vaste et la fonctionnalité de ce logiciel et identifiez les interfaces entre les deux. 
Un diagramme simple qui montre les principaux composants du système global, les interconnexions des sous-systèmes et les interfaces externes peut être utile.
====

=== Fonctionnalités du produit

Le logiciel {project} doit assurer deux fonctions principales :

. Création de jeu : permettre à deux joueurs de se découvrir et de commencer une partie.
. Le jeu{nbsp}: permettre aux joueurs de jouer effectivement à {project} jusqu'à la victoire de l'un d'entre eux.

[NOTE]
====
Une image des principaux groupes d'exigences connexes et de leurs relations, comme une carte conceptuelle, est souvent utile.
====


=== Caractéristiques et classes d'utilisateurs

[NOTE]
====
Identifiez les différentes classes d'utilisateurs qui, selon vous, utiliseront ce produit. 
Les classes d'utilisateurs peuvent être différenciées en fonction de la fréquence d'utilisation, du sous-ensemble de fonctions du produit utilisé, de l'expertise technique, des niveaux de sécurité ou de privilège, du niveau d'éducation ou de l'expérience. 
Décrivez les caractéristiques pertinentes de chaque classe d'utilisateurs.  Certaines exigences peuvent ne concerner que certaines classes d'utilisateurs. 
Distinguez les classes d'utilisateurs les plus importantes pour ce produit de celles qui sont moins importantes à satisfaire.
====

Le logiciel {project} n'a qu'une seule classe d'utilisateurs : les joueurs.
Les joueurs peuvent avoir différents niveaux : débutants, intermédiaires ou experts.
Cependant, indépendamment de leur niveau, les joueurs doivent utiliser la même interface utilisateur pour jouer les uns contre les autres.

[NOTE]
====
TODO: Complétez la description ci-dessus
====

=== Environnement opérationnel

NOTE: Décrivez l'environnement dans lequel le logiciel fonctionnera, y compris la plate-forme matérielle, le système d'exploitation et ses versions, ainsi que tout autre composant logiciel ou application avec lequel il doit coexister pacifiquement.

Le logiciel {project} doit fonctionner sur tout système d'exploitation populaire et récent{nbsp}: Linux, Windows, ou MacOS.
Le client Web devrait fonctionner sur tout navigateur Web récent{nbsp}: Firefox, Chrome, Safari, ou Edge.

[NOTE]
====
TODO: Complétez la description ci-dessus
====

== Contraintes de conception et de mise en œuvre

=== Langages de programmation

. Le serveur de jeu doit être développé en Java (version ≥ 11), en utilisant le https://spring.io [Spring Framework].
. Le client doit être développé en TypeScript (version ≥ 4.0), en utilisant le https://angular.io [Angular Framework].


=== Langage de conception

. Les documents sur le développement du logiciel doivent être écrits dans le format Asciidoc.
. Les diagrammes UML d'analyse, conception et mise en œuvre devront être réalisés en PlantUML.

=== Conception
=== Mise en œuvre

. Les tests dynamiques doivent utiliser JUnit (version >= 5.0) et Jasmine (version >= 3.5.0).
. Le code doit journaliser ses principales opérations en utilisant https://www.slf4j.org [SLF4J].

=== Outils de construction

. Tous les artefacts logiciels doivent utiliser un outil de construction : Maven ou Groovy pour Java, npm pour TypeScript.

=== Outils de développement
=== Bibliothèques et composants logiciels


== Vérification

. Les doubles tests doivent être utilisés pour tester chaque composant indépendamment.
. Chaque test unitaire doit décrire son intention.

== Documentation utilisateur

Aucune documentation utilisateur n'est requise pour la première version du logiciel.

=== Hypothèses et dépendances

Aucun jusqu'à présent.

=== Exigences reportées

[NOTE]
====
Énumérer les exigences qui peuvent être réalisées dans des versions futures du système.
Les versions futures du système comprendront l’utilisation d’un mécanisme de persistance de données ainsi que différentes interfaces utilisateur: web, IHM classique, etc.
Elles permettront aussi l’accès distant à travers une interface REST.
====

== Exigences en matière d'interface externe

=== Interfaces utilisateur

[NOTE]
====
Décrivez les caractéristiques logiques de chaque interface entre le produit logiciel et les utilisateurs. 

Il peut s'agir d'exemples d'images d'écran, de normes d'interface graphique ou de guides de style de famille de produits à respecter, de contraintes de disposition des écrans, de boutons et de fonctions standard (p. ex., aide) qui apparaîtront sur chaque écran, de raccourcis clavier, de normes d'affichage des messages d'erreur, etc. 

Définissez les composants logiciels pour lesquels une interface utilisateur est nécessaire. 
Les détails de la conception de l'interface utilisateur doivent être documentés dans une spécification d'interface utilisateur distincte.
====

=== Interfaces matérielles

Le logiciel n'interagit pas directement avec un quelconque dispositif matériel.

=== Interfaces logicielles

La partie client du logiciel doit fonctionner sur des navigateurs web, tandis que la partie serveur doit interagir avec une base de données par le biais de l'API Java Persistence (JPA).



=== Interfaces de communication

Les communications entre le client et le serveur de jeu doivent utiliser des Websockets.

[#features]
== Exigences fonctionnelles

[NOTE]
====
Décrire les exigences fonctionnelles du système qui peuvent être exprimées et langage naturel. Pour plusieurs applications, c’est la partie principale de la SEL et son organisation doit, par conséquent, être bien réfléchie. Elle est habituellement hiérarchisée par caractéristiques, mais elle peut l’être, par utilisateur ou par sous-système. Les exigences fonctionnelles peuvent inclure les caractéristiques, les capacités et la sécurité.

Lorsque des outils de développement, tels des référentiels d’exigences ou des outils de modélisation sont utilisés, on peut référer à ces données en indiquant l’endroit et le nom de cet outil]
====

[TIP]
====
Ici, il ne s'agit plus de décrire le domaine métier, mais de spécifier ce que le système *doit* faire.

N'oubliez pas qu'il s'agit d'une spécification de que le système *doit* faire et non pas de *comment* il le fait.
====

=== Fonctionnalité A

[NOTE]
====
Ajoutez la description de la fonctionnalité "A".
====

TIP: Ne dites pas vraiment "Fonctionnalité A". Indiquez le nom de la fonctionnalité en quelques mots seulement.

==== Description et priorité

[NOTE]
====
Fournissez une brève description de la fonctionnalité et indiquez si elle a une priorité élevée, moyenne ou faible. 
Vous pouvez également inclure des évaluations spécifiques des éléments de priorité, comme les avantages, les pénalités, les coûts et les risques (chacun étant évalué sur une échelle relative allant de 1 à 9).
====

==== Séquences de Stimulus/Réponse

NOTE: Liste des séquences d'actions de l'utilisateur et des réponses du système qui stimulent le comportement défini pour cette fonctionnalité. Celles-ci correspondront aux éléments de dialogue associés aux cas d'utilisation.

==== Exigences fonctionnelles

[NOTE]
====
Détaillez les exigences fonctionnelles détaillées associées à cette fonctionnalité. Il s'agit des capacités logicielles qui doivent être présentes pour permettre à l'utilisateur d'effectuer les services fournis par la fonction ou d'exécuter le cas d'utilisation. 

Indiquez comment le produit doit réagir aux conditions d'erreur prévues ou aux entrées non valides. Les exigences doivent être concises, complètes, non ambiguës, vérifiables et nécessaires. 

Utilisez la mention "A faire" pour indiquer que les informations nécessaires ne sont pas encore disponibles.

Chaque exigence doit être identifiée de manière unique par un numéro de séquence ou une étiquette significative.

* REQ-1:	
* REQ-2:
====

==== Description sous la forme d'un cas d'utilisation

.Cas d'utilisation A
include::partial$uc-a.adoc[]

=== Fonctionnalité B

NOTE: Ajoutez la description de la fonctionnalité "B" en vous basant sur la structure de la fonctionnalité "A"

==== Description sous la forme d'un cas d'utilisation
.Cas d'utilisation B
include::partial$uc-b.adoc[]

=== Fonctionnalité C

NOTE: Ajoutez la description de la fonctionnalité "C" en vous basant sur la structure de la fonctionnalité "A"

==== Description sous la forme d'un cas d'utilisation

.Cas d'utilisation C
include::partial$uc-c.adoc[]


[#nonfunctional]
== Autres exigences non-fonctionnelles

=== Exigences de performance 

. Le jeu doit être _jouable_, ce qui signifie que les utilisateurs doivent avoir un retour rapide de leurs actions et que les retards dus aux problèmes de communication/connexion doivent être correctement tenus.
. Le client Web doit pouvoir s'exécuter sur un ordinateur personnel doté de 4 Go de RAM.


=== Exigences de sécurité

NOTE: Précisez toute exigence concernant les questions de sécurité ou de confidentialité entourant l'utilisation du produit ou la protection des données utilisées ou créées par le produit. Définissez toute exigence en matière d'authentification de l'identité de l'utilisateur. Faites référence à toute politique ou réglementation externe contenant des questions de sécurité qui affectent le produit. Définissez toutes les certifications de sécurité ou de confidentialité qui doivent être satisfaites.

=== Attributs de qualité logicielle

[NOTE]
====
Précisez toute autre caractéristique de qualité du produit qui sera importante pour les clients ou les développeurs. En voici quelques-unes : adaptabilité, disponibilité, exactitude, flexibilité, interopérabilité, maintenabilité, portabilité, fiabilité, réutilisabilité, robustesse, testabilité et convivialité. 

Rédigez-les de manière à ce qu'elles soient spécifiques, quantitatives et vérifiables, si possible. 

Au minimum, clarifiez les préférences relatives pour divers attributs, comme la facilité d'utilisation par rapport à la facilité d'apprentissage. 
====

==== Extensibilité

NOTE: TODO

==== Maintenabilité

. Le logiciel doit être lisible et facile à maintenir.
. La source Java doit respecter les directives de Google : https://google-styleguide.googlecode.com/svn/trunk/javaguide.html.

=== Règles métier

NOTE: Énumérez tous les principes de fonctionnement du produit, tels que les personnes ou les rôles qui peuvent remplir telle ou telle fonction dans des circonstances spécifiques. Il ne s'agit pas d'exigences fonctionnelles en soi, mais elles peuvent impliquer certaines exigences fonctionnelles pour faire respecter les règles.


== Autres exigences

NOTE: Définissez toute autre exigence non couverte ailleurs dans le SRS. Il peut s'agir d'exigences relatives à la base de données, à l'internationalisation, à la législation, aux objectifs de réutilisation du projet, etc. Ajoutez toute nouvelle section pertinente pour le projet.

=== Annexe A : Glossaire

TIP: https://docs.asciidoctor.org/asciidoc/latest/sections/glossary/


NOTE: Définissez tous les termes nécessaires pour interpréter correctement le SRS, y compris les acronymes et les abréviations. Vous pouvez créer un glossaire distinct couvrant plusieurs projets ou l'ensemble de l'organisation, et vous contenter d'inclure les termes spécifiques à un seul projet dans chaque SRS.

=== Annexe B : Modèles d'analyse

Voir le chapitre <<domain>> (analyse du domaine) pour plus de détails.

NOTE: En option, inclure tout modèle d'analyse pertinent, tel que des diagrammes de flux de données, des diagrammes de classe, des diagrammes d'état-transition ou des diagrammes entité-relation.

=== Annexe C : Liste à déterminer

NOTE: Recueillir une liste numérotée des références TBD (To Be Done) qui restent dans le SRS afin de pouvoir les suivre jusqu'à leur fermeture.
